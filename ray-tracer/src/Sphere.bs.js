// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Ray$RayTracer = require("./Ray.bs.js");
var Vec3$RayTracer = require("./Vec3.bs.js");
var HitRecord$RayTracer = require("./HitRecord.bs.js");

function make(center, radius, material) {
  return /* record */[
          /* center */center,
          /* radius */radius,
          /* material */material
        ];
}

function hit(sphere, ray, tMin, tMax) {
  var oc = Vec3$RayTracer.sub(ray[/* origin */0], sphere[/* center */0]);
  var a = Vec3$RayTracer.dot(ray[/* direction */1], ray[/* direction */1]);
  var b = Vec3$RayTracer.dot(oc, ray[/* direction */1]);
  var c = Vec3$RayTracer.dot(oc, oc) - sphere[/* radius */1] * sphere[/* radius */1];
  var discriminant = b * b - a * c;
  if (discriminant > 0.0) {
    var temp1 = (-b - Math.sqrt(discriminant)) / a;
    if (temp1 < tMax && temp1 > tMin) {
      var p = Ray$RayTracer.pointAtParameter(ray, temp1);
      return HitRecord$RayTracer.make(temp1, p, Vec3$RayTracer.div(Vec3$RayTracer.sub(p, sphere[/* center */0]), sphere[/* radius */1]), sphere[/* material */2]);
    } else {
      var temp2 = (-b + Math.sqrt(discriminant)) / a;
      var p$1 = Ray$RayTracer.pointAtParameter(ray, temp2);
      if (temp2 < tMax && temp2 > tMin) {
        return HitRecord$RayTracer.make(temp2, p$1, Vec3$RayTracer.div(Vec3$RayTracer.sub(p$1, sphere[/* center */0]), sphere[/* radius */1]), sphere[/* material */2]);
      } else {
        return undefined;
      }
    }
  }
  
}

exports.make = make;
exports.hit = hit;
/* No side effect */
